[{"title":"mybatis","path":"2022/03/05/mybatis/","text":"1.MyBatis介绍环境说明 jdk 8 + MySQL 5.7.19 maven-3.6.1 IDEA 学习前需要掌握： JDBC MySQL Java 基础 Maven Junit 什么是MyBatis MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3 持久化持久化是将程序数据在持久状态和瞬时状态间转换的机制。 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 持久层 完成持久化工作的代码块 . —-&gt; dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】 为什么需要MyBatis Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . 传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 . MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) –&gt;对象关系映射 所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别 MyBatis的优点 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。 2、第一个程序思路流程：搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试 1、搭建实验数据库12345678910111213CREATE DATABASE `mybatis`;USE `mybatis`;DROP TABLE IF EXISTS `user`;CREATE TABLE `user`(`id` INT(20) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,`pwd` VARCHAR(30) DEFAULT NULL,PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO USER VALUES(1,&#x27;安安&#x27;,123),(2,&#x27;姜芃姬&#x27;,123),(3,&#x27;东姝&#x27;,123); 2、导入MyBatis相关jar包12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; 123456789101112131415161718192021#过滤静态资源 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 3、编写MyBatis核心配置文件12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.aimer.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;106606&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 4、MyBatis工具类123456789101112131415161718//连接数据库public class MyBatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //获取SqlSession连接 public static SqlSession getSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 3、CRUD1、namespace配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名,必须一致 2、select select标签是mybatis中最常用的标签之一 select语句有很多属性可以详细配置每一条SQL语句 SQL语句返回值类型。【完整的类名或者别名】 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 id parameterType resultType 需求：根据id查询用户 1、在UserMapper中添加对应方法 123456public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; selectUser(); //根据id查询用户 User selectUserById(int id);&#125; 2、在UserMapper.xml中添加Select语句 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.aimer.mybatis.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.aimer.mybatis.pojo.User&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3、测试类中测试 12345678@Testpublic void tsetSelectUserById() &#123; SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();&#125; 思路一：直接在方法中传递参数 1、在接口方法的参数前加 @Param属性 2、Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型 12345678//通过密码和名字查询用户User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) Stringpwd);/* &lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125; &lt;/select&gt;*/ 思路二：使用万能的Map 1、在接口方法中，参数直接传递Map； 1User selectUserByNP2(Map&lt;String,Object&gt; map); 2、编写sql语句的时候，需要传递参数类型，参数类型为map 123&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot;resultType=&quot;com.kuang.pojo.User&quot;&gt;select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;&lt;/select&gt; 3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！ 1234Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();map.put(&quot;username&quot;,&quot;小明&quot;);map.put(&quot;pwd&quot;,&quot;123456&quot;);User user = mapper.selectUserByNP2(map); 总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可 3、insert我们一般使用insert标签进行插入操作，它的配置和select标签差不多！ 需求：给数据库增加一个用户 1、在UserMapper接口中添加对应的方法 12//添加一个用户int addUser(User user); 2、在UserMapper.xml中添加insert语句 123&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&lt;/insert&gt; 3、测试 12345678910@Testpublic void testAddUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;); int i = mapper.addUser(user); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close();&#125; 注意点：增、删、改操作需要提交事务！ 4、update我们一般使用update标签进行更新操作，它的配置和select标签差不多！ 需求：修改用户的信息 1、同理，编写接口方法 12//修改一个用户int updateUser(User user); 2、编写对应的配置文件SQL 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&lt;/update&gt; 3、测试 1234567891011@Testpublic void testUpdateUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); user.setPwd(&quot;asdfgh&quot;); int i = mapper.updateUser(user); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close();&#125; 5、delete我们一般使用delete标签进行删除操作，它的配置和select标签差不多！ 需求：根据id删除一个用户 1、同理，编写接口方法 12//根据id删除用户int deleteUser(int id); 2、编写对应的配置文件SQL 123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125;&lt;/delete&gt; 3、测试 123456789@Testpublic void testDeleteUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int i = mapper.deleteUser(5); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close();&#125; 小结： 所有的增删改操作都需要提交事务！ 接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！ 有时候根据业务的需求，可以考虑使用map传递参数！ 为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！ 6、模糊查询模糊查询like语句该怎么写? 第1种：在Java代码中添加sql通配符。 123456string wildcardname = “%smi%”;list&lt;name&gt; names = mapper.selectlike(wildcardname);&lt;select id=”selectlike”&gt;select * from foo where bar like #&#123;value&#125;&lt;/select&gt; 第2种：在sql语句中拼接通配符，会引起sql注入 123456string wildcardname = “smi”;list&lt;name&gt; names = mapper.selectlike(wildcardname);&lt;select id=”selectlike”&gt; select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;&lt;/select&gt; 4、配置解析1、核心配置文件 mybatis-config.xml 系统核心配置文件 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 能配置的内容如下： 1234567891011121314configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器）&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt; 我们可以阅读 mybatis-config.xml 上面的dtd的头文件！ 2、environments元素12345678910111213&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定） 子元素节点： environment dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 数据源是必须配置的。 有三种内建的数据源类型 1type=&quot;[UNPOOLED|POOLED|JNDI]&quot;） unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. 这两种事务管理器类型都不需要设置任何属性。 具体的一套环境，通过设置id进行区别，id保证唯一！ 子元素节点：transactionManager - [ 事务管理器 ] 12&lt;!-- 语法 --&gt;&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt; 子元素节点：数据源（dataSource） 3、mappers元素mappers 映射器 : 定义映射SQL语句文件 既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。 引入资源方式 123456789101112131415161718192021222324&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/*Mapper.xml&quot;/&gt; //可一次通配引入所有资源，但接口不可以&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!--使用映射器接口实现类的完全限定类名需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt;&lt;!--将包内的映射器接口实现全部注册为映射器但是需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; Mapper文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;&lt;http://mybatis.org/dtd/mybatis-3-mapper.dtd&gt;&quot;&gt;&lt;mapper namespace=&quot;com.aimer.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; namespace中文意思：命名空间，作用如下： namespace的命名必须跟某个接口同名 接口中的方法与映射文件中sql语句id应该一一对应 namespace和子元素的id联合保证唯一 , 区别不同的mapper 绑定DAO接口 namespace命名规则 : 包名+类名 MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。 4、properties优化数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。具体的官方文档 我们来优化我们的配置文件 第一步 ; 在资源目录下新建一个db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8username=rootpassword=123456 第二步 : 将文件导入properties 配置文件 12345678910111213141516171819&lt;configuration&gt; &lt;!--导入properties文件--&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 5、typeAliases优化类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 1234&lt;!--配置别名,注意顺序--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，User可以用在任何使用com.kuang.pojo.User的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如: 123&lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt;&lt;/typeAliases&gt; 每一个在包 com.kuang.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 若有注解，则别名为其注解值。见下面的例子： 1234@Alias(&quot;user&quot;)public class User &#123; ...&#125; 去官网查看一下Mybatis默认的一些类型别名！ 6、其他设置设置 设置（settings）相关 =&gt; 查看帮助文档 懒加载 日志实现 缓存开启关闭 一个配置完整的 settings 元素的示例如下： 1234567891011121314151617&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; 类型处理器 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】 对象工厂 MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】 7、生命周期生命周期，和作用域，是至关重要的，因为错误的使用会导致非常重要的并发问题 作用域理解 SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。 由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。 因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 SqlSessionFactory 的最佳作用域是应用作用域。 如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。 所以 SqlSession 的最佳的作用域是请求或方法作用域。 5、解决属性名和字段名不一致的问题1、问题 （查询为null）2、Java中的实体类设计 12345678910public class User &#123; private int id; //id private String name; //姓名 private String password; //密码和数据库不一样！ //构造 //set/get //toString()&#125; 3、接口 12//根据id查询用户User selectUserById(int id); 4、mapper映射文件 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 5、测试 12345678@Testpublic void testSelectUserById() &#123; SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();&#125; 结果: User{id=1, name=’狂神’, password=’null’} 查询出来发现 password 为空 . 说明出现了问题！ 分析： select * from user where id = #{id} 可以看做 select id,name,pwd from user where id = #{id} mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】 2、解决方案方案一：为列名指定别名 , 别名和java实体类的属性名一致 . 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt; select id , name , pwd as password from user where id = #&#123;id&#125;&lt;/select&gt; 方案二：使用结果集映射-&gt;ResultMap 【推荐】 1234567891011&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- id为主键 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt; select id , name , pwd from user where id = #&#123;id&#125;&lt;/select&gt; ResultMap 自动映射 resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来。 实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。 ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 你已经见过简单映射语句的示例了，但并没有显式指定 resultMap。比如： 12345&lt;select id=&quot;selectUserById&quot; resultType=&quot;map&quot;&gt;select id , name , pwd from user where id = #&#123;id&#125;&lt;/select&gt; 上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。 ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。 手动映射 1、返回值类型为resultMap 123&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt; select id , name , pwd from user where id = #&#123;id&#125;&lt;/select&gt; 2、编写resultMap，实现手动映射！ 1234567&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- id为主键 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt; 如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消化掉才是最重要的！理解结果集映射的这个概念！ 6、日志思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？ 如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。 对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。 Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具： SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging 具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用 标准日志实现 指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; 1、log4j Log4j是Apache的一个开源项目 通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件…. 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 使用步骤： 1、导入log4j的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 2、配置文件编写 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/kuang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 3、setting设置日志实现 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 4、在程序中使用Log4j进行输出！ 12345678910111213141516//注意导包：org.apache.log4j.Loggerstatic Logger logger = Logger.getLogger(MyTest.class);@Testpublic void selectUser() &#123; logger.info(&quot;info：进入selectUser方法&quot;); logger.debug(&quot;debug：进入selectUser方法&quot;); logger.error(&quot;error: 进入selectUser方法&quot;); SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users)&#123; System.out.println(user); &#125; session.close();&#125; 5、测试，看控制台输出！ 使用Log4j 输出日志 可以看到还生成了一个日志的文件 【需要修改file的日志级别】 7、分页在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。 1、limit实现分页123456789101112#语法SELECT * FROM table LIMIT stratIndex，pageSizeSELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 #为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. #如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行 #换句话说，LIMIT n 等价于 LIMIT 0,n。 步骤： 1、修改Mapper文件 123&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt; select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt; 2、Mapper接口，参数为map 12//选择全部用户实现分页List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map); 3、在测试类中传入参数测试 推断：起始位置 = （当前页面 - 1 ） * 页面大小 1234567891011121314151617181920//分页查询 , 两个参数startIndex , pageSize@Testpublic void testSelectUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int currentPage = 1; //第几页 int pageSize = 2; //每页显示几个 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize); map.put(&quot;pageSize&quot;,pageSize); List&lt;User&gt; users = mapper.selectUser(map); for (User user: users)&#123; System.out.println(user); &#125; session.close();&#125; 2、RowBounds分页我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！ 1234567891011public void selectUserByRowBounds()&#123; SqlSession session = MyBatisUtils.getSession(); //RowBounds的实现 RowBounds rowBounds = new RowBounds(1,2);//从第一个二开始，每页查询两个 //传统的实现方法 List&lt;User&gt; userList = session.selectList(&quot;com.aimer.Dao.UserMapper.selectUserByRowBounds&quot;,null,rowBounds) ; for (User user : userList) &#123; System.out.println(user); &#125; session.close(); &#125; 8、注解开发8.1、面向接口编程 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）； 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向区别 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 . 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 . 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构 8.2、利用注解开发 mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建 sql 类型主要分成 : @select () @update () @Insert () @delete () 注意：利用注解开发就不需要mapper.xml映射文件了 . 1、我们在我们的接口中添加注解 123//查询全部用户@Select(&quot;select id,name,pwd password from user&quot;)public List&lt;User&gt; getAllUser(); 2、在mybatis的核心配置文件中注入 1234&lt;!--使用class绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.kuang.mapper.UserMapper&quot;/&gt;&lt;/mappers&gt; 3、我们去进行测试 12345678910111213@Testpublic void testGetAllUser() &#123; SqlSession session = MybatisUtils.getSession(); //本质上利用了jvm的动态代理机制 UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.getAllUser(); for (User user : users)&#123; System.out.println(user); &#125; session.close();&#125; 4、利用Debug查看本质 5、本质上利用了jvm的动态代理机制 6、Mybatis详细的执行流程 8.3、CRUD改造MybatisUtils工具类的getSession( ) 方法，重载实现。 12345678//获取SqlSession连接public static SqlSession getSession()&#123; return getSession(true); //事务自动提交&#125; public static SqlSession getSession(boolean flag)&#123; return sqlSessionFactory.openSession(flag);&#125; 【注意】确保实体类和数据库字段对应 查询：1、编写接口方法注解 123//根据id查询用户@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User selectUserById(@Param(&quot;id&quot;) int id); 2、测试 12345678910@Testpublic void testSelectUserById() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();&#125; 新增：1、编写接口方法注解 123//添加一个用户@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)int addUser(User user); 2、测试 12345678910@Testpublic void testAddUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, &quot;秦疆&quot;, &quot;123456&quot;); mapper.addUser(user); session.close();&#125; 修改：1、编写接口方法注解 123//修改一个用户@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;)int updateUser(User user); 2、测试 12345678910@Testpublic void testUpdateUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, &quot;秦疆&quot;, &quot;zxcvbn&quot;); mapper.updateUser(user); session.close();&#125; 删除：1、编写接口方法注解 123//根据id删除用@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)int deleteUser(@Param(&quot;id&quot;)int id); 2、测试 123456789@Testpublic void testDeleteUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); mapper.deleteUser(6); session.close();&#125; 【注意点：增删改一定记得对事务的处理】 8.4、关于@Param有多个参数的时候使用@Param @Param注解用于给方法参数起一个名字。以下是总结的使用原则： 在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是Javabean。 例如： 1User getUserByID(@Param(&quot;id&quot;) int id,@Param(&quot;name&quot;) String name) Param中的名字优先级高于后面的int定义的名字 8.5、#{} 和 ${} 的区别： #{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】 12INSERT INTO user (name) VALUES (#&#123;name&#125;);INSERT INTO user (name) VALUES (?); ${} 的作用是直接进行字符串替换 12INSERT INTO user (name) VALUES (&#x27;$&#123;name&#125;&#x27;);INSERT INTO user (name) VALUES (&#x27;kuangshen&#x27;); 9、Lombok使用前先下载插件 导入jar包 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 12345678910111213141516171819202122val: final 像动态语言一样，声明一个fianl的变量。var: 同JDK10@Data：注解在类上，将类提供的所有属性都添加get、set方法，并添加、equals、canEquals、hashCode、toString方法@Setter：注解在类上，为所有属性添加set方法、注解在属性上为该属性提供set方法@Getter：注解在类上，为所有的属性添加get方法、注解在属性上为该属性提供get方法@NotNull：在参数中使用时，如果调用时传了null值，就会抛出空指针异常@Synchronized 用于方法，可以锁定指定的对象，如果不指定，则默认创建一个对象锁定@Log作用于类，创建一个log属性@Builder：使用builder模式创建对象@NoArgsConstructor：创建一个无参构造函数@AllArgsConstructor：创建一个全参构造函数@ToString：创建一个toString方法@Accessors(chain = true)使用链式设置属性，set方法返回的是this对象。@RequiredArgsConstructor：创建对象, 例: 在class上添加@RequiredArgsConstructor(staticName = &quot;of&quot;)会创建生成一个静态方法@UtilityClass:工具类@ExtensionMethod:设置父类@FieldDefaults：设置属性的使用范围，如private、public等，也可以设置属性是否被final修饰。@Cleanup: 关闭流、连接点。@EqualsAndHashCode：重写equals和hashcode方法。@toString：创建toString方法。@Cleanup: 用于流等可以不需要关闭使用流对象. 常用的就的@Data，可以直接生成：无参构造、hashcode、get、set、toString、equals 10、多对一多对一的理解： 多个学生对应一个老师 如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！ 10.1、数据库设计1234567891011121314151617181920212223CREATE TABLE `teacher` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;);CREATE TABLE `student` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,`tid` INT(10) DEFAULT NULL,PRIMARY KEY (`id`),KEY `fktid` (`tid`),CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;); 10.2、环境搭建1、IDEA安装Lombok插件2、引入Maven依赖123456&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt;&lt;/dependency&gt; 3、在代码中增加注解123456789101112@Data //GET,SET,ToString，有参，无参构造public class Teacher &#123; private int id; private String name;&#125;@Datapublic class Student &#123; private int id; private String name; //多个学生可以是同一个老师，即多对一 private Teacher teacher;&#125; 4、编写实体类对应的Mapper接口 【两个】 无论有没有需求，都应该写上，以备后来之需！ 1234public interface StudentMapper &#123;&#125;public interface TeacherMapper &#123;&#125; 5、编写Mapper接口对应的 mapper.xml配置文件 【两个】 无论有没有需求，都应该写上，以备后来之需！ 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;&lt;/mapper&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;&lt;/mapper&gt; 10.3、按查询嵌套处理1、给StudentMapper接口增加方法 12//获取所有学生及对应老师的信息public List&lt;Student&gt; getStudents(); 2、编写对应的Mapper文件 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt; &lt;!-- 需求：获取所有学生及对应老师的信息 思路： 1. 获取所有学生的信息 2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息 3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？ 1. 做一个结果集映射：StudentTeacher 2. StudentTeacher结果集的类型为 Student 3. 学生中老师的属性为teacher，对应数据库中为tid。 多个 [1,...）学生关联一个老师=&gt; 一对一，一对多 4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询 --&gt; &lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt; &lt;/resultMap&gt; &lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=&quot;&#123;key=value,key=value&#125;&quot; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --&gt; &lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3、编写完毕去Mybatis配置文件中，注册Mapper！ 4、注意点说明： 12345678910111213&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt; &lt;association property=&quot;teacher&quot; column=&quot;&#123;id=tid,name=tid&#125;&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;!--这里传递过来的id，只有一个属性的时候，下面可以写任何值association中column多参数配置： column=&quot;&#123;key=value,key=value&#125;&quot; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。--&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 5、测试 12345678910111213@Testpublic void testGetStudents()&#123; SqlSession session = MybatisUtils.getSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); List&lt;Student&gt; students = mapper.getStudents(); for (Student student : students)&#123; System.out.println( &quot;学生名:&quot;+ student.getName() +&quot;\\t老师:&quot;+student.getTeacher().getName()); &#125;&#125; 11、多对一多对一的理解： 多个学生对应一个老师 如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！ 12、动态SQL12.1 if 语句1234567891011121314&lt;!--需求1：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;--&gt;&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog where &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; 12.2 where1234567891011&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。 12.3 set12345678910111213&lt;!--注意set是用的逗号隔开--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #&#123;author&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;;&lt;/update&gt; 12.4 choose语句12345678910111213141516&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 12.5 SQL片段提取SQL片段： 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 引用SQL片段： 12345678&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt; &lt;/where&gt;&lt;/select&gt; 注意： ①、最好基于 单表来定义 sql 片段，提高片段的可重用性 ②、在 sql 片段中不要包括 where 12.6 Foreach将数据库中前三个数据的id修改为1,2,3； 需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息 1、编写接口 1List&lt;Blog&gt; queryBlogForeach(Map map); 2、编写SQL语句 12345678910111213141516&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from blog where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 13、缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 13.1 一级缓存一级缓存也叫本地缓存： 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 测试 1、在mybatis中加入日志，方便测试结果 2、编写接口方法 12//根据id查询用户User queryUserById(@Param(&quot;id&quot;) int id); 3、接口对应的Mapper文件 123&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 4、测试 12345678910111213@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 一级缓存失效的四种情况 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！ 1、sqlSession不同 12345678910111213141516@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); session2.close();&#125; 观察结果：发现发送了两条SQL语句！ 结论：每个sqlSession中的缓存相互独立 2、sqlSession相同，查询条件不同 1234567891011121314@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(2); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 观察结果：发现发送了两条SQL语句！很正常的理解 结论：当前缓存中，不存在这个数据 3、sqlSession相同，两次查询之间执行了增删改操作！ 增加方法 12//修改用户int updateUser(Map map); 编写SQL 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt; update user set name = #&#123;name&#125; where id = #&#123;id&#125;&lt;/update&gt; 测试 1234567891011121314151617181920@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); HashMap map = new HashMap(); map.put(&quot;name&quot;,&quot;kuangshen&quot;); map.put(&quot;id&quot;,4); mapper.updateUser(map); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 观察结果：查询在中间执行了增删改操作后，重新执行了 结论：因为增删改操作可能会对当前数据产生影响 4、sqlSession相同，手动清除一级缓存 1234567891011121314151617@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.clearCache();//手动清除缓存 User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 一级缓存就是一个map 13.2 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 使用步骤 1、开启全局缓存 【mybatis-config.xml】 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】 123456789&lt;cache/&gt;官方示例=====&gt;查看官方文档&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 3、代码测试 所有的实体类先实现序列化接口 测试代码 123456789101112131415161718@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.close(); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session2.close();&#125; 结论 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 14、逆向工程mybaits需要程序员自己编写sql语句，mybatis官方提供逆向工程，可以针对单表自动生成mybatis执行所需要的代码（mapper.java,mapper.xml、po..） 1、下载逆向工程文件123456789101112131415&lt;build&gt; &lt;finalName&gt;SpringMVCBasic&lt;/finalName&gt; &lt;!-- 添加mybatis-generator-maven-plugin插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、生成代码配置文件在maven项目下的src/main/resources 目录下新建generatorConfig.xml和generator.properties配置文件 generator.properties：12345jdbc.driverLocation=C:\\\\Users\\\\Yvettee\\\\.m2\\\\repository\\\\mysql\\\\mysql-connector-java\\\\5.1.18\\\\mysql-connector-java-5.1.18.jarjdbc.driverClass=com.mysql.jdbc.Driverjdbc.connectionURL=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8jdbc.userId=rootjdbc.password=root generatorConfig.xml:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置--&gt; &lt;properties resource=&quot;generator.properties&quot;&gt;&lt;/properties&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置(绝对路径)--&gt; &lt;classPathEntry location=&quot;$&#123;jdbc.driverLocation&#125;&quot;/&gt; &lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;!--是否去掉自动生成的注释 true:是--&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接：驱动类、链接地址、用户名、密码--&gt; &lt;jdbcConnection driverClass=&quot;$&#123;jdbc.driverClass&#125;&quot; connectionURL=&quot;$&#123;jdbc.connectionURL&#125;&quot; userId=&quot;$&#123;jdbc.userId&#125;&quot; password=&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.eurasia.pojo&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name=&quot;constructorBased&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.eurasia.dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和基于注解的Mapper对象 type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象 type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator targetPackage=&quot;com.eurasia.mapper&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 数据表进行生成操作 tableName:表名; domainObjectName:对应的DO --&gt; &lt;table tableName=&quot;items&quot; domainObjectName=&quot;Items&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;table tableName=&quot;orderdetail&quot; domainObjectName=&quot;Orderdetail&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;table tableName=&quot;orders&quot; domainObjectName=&quot;Orders&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3. 在Intellij IDEA添加一个“Run运行”选项使用maven运行mybatis-generator-maven-plugin插件 4. 在name和Commond line分别填上如上图所示，再点击Apply和OK。"},{"title":"SpringMVC","path":"2022/03/05/springmvc-shang-huo-gu-bi-ji/","text":"[TOC] 一、SpringMVC简介1、什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 MVC的工作流程：用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器 2、什么是SpringMVCSpringMVC是Spring的一个后续产品，是Spring的一个子项目 SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet 3、SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 二、HelloWorld1、开发环境IDE：idea 2019.2 构建工具：maven3.5.4 服务器：tomcat7 Spring版本：5.3.1 2、创建maven工程a&gt;添加web模块b&gt;打包方式：warc&gt;引入依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。 3、配置web.xml注册SpringMVC的前端控制器DispatcherServlet a&gt;默认配置方式此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml 1234567891011121314&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; b&gt;扩展配置方式可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间 123456789101112131415161718192021222324252627&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation为固定值 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注： &lt;url-pattern&gt;标签中使用/和/*的区别： /所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求 因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面 /*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法 4、创建请求控制器由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器 请求控制器中每一个处理请求的方法成为控制器方法 因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在 1234@Controllerpublic class HelloController &#123; &#125; 5、创建springMVC的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 自动扫描包 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;/&gt;&lt;!-- 配置Thymeleaf视图解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置&lt;mvc:annotation-driven/&gt;解决问题 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 开启mvc注解驱动 --&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;!-- 处理响应中文内容乱码 --&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 6、测试HelloWorlda&gt;实现对首页的访问在请求控制器中创建处理请求的方法 12345678// @RequestMapping注解：处理请求和控制器方法之间的映射关系// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径// localhost:8080/springMVC/@RequestMapping(&quot;/&quot;)public String index() &#123; //设置视图名称 return &quot;index&quot;;&#125; b&gt;通过超链接跳转到指定页面在主页index.html中设置超链接 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;HelloWorld&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 在请求控制器中创建处理请求的方法 1234@RequestMapping(&quot;/hello&quot;)public String HelloWorld() &#123; return &quot;target&quot;;&#125; 7、总结浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面 三、@RequestMapping注解1、@RequestMapping注解的功能从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。 2、@RequestMapping注解的位置@RequestMapping标识一个类：设置映射请求的请求路径的初始信息 @RequestMapping标识一个方法：设置映射请求请求路径的具体信息 1234567891011@Controller@RequestMapping(&quot;/test&quot;)public class RequestMappingController &#123; //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping @RequestMapping(&quot;/testRequestMapping&quot;) public String testRequestMapping()&#123; return &quot;success&quot;; &#125;&#125; 3、@RequestMapping注解的value属性@RequestMapping注解的value属性通过请求的请求地址匹配请求映射 @RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求 @RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射 12&lt;a th:href=&quot;@&#123;/testRequestMapping&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/testRequestMapping&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt; 123456@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 4、@RequestMapping注解的method属性@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported 1234&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt;&lt;form th:action=&quot;@&#123;/test&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 1234567@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解 处理get请求的映射–&gt;@GetMapping 处理post请求的映射–&gt;@PostMapping 处理put请求的映射–&gt;@PutMapping 处理delete请求的映射–&gt;@DeleteMapping 2、常用的请求方式有get，post，put，delete 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到 5、@RequestMapping注解的params属性（了解）@RequestMapping注解的params属性通过请求的请求参数匹配请求映射 @RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 “param”：要求请求映射所匹配的请求必须携带param请求参数 “!param”：要求请求映射所匹配的请求必须不能携带param请求参数 “param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value “param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value 1&lt;a th:href=&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;&gt;测试@RequestMapping的params属性--&gt;/test&lt;/a&gt;&lt;br&gt; 12345678@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125; ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125; ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456} 6、@RequestMapping注解的headers属性（了解）@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射 @RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系 “header”：要求请求映射所匹配的请求必须携带header请求头信息 “!header”：要求请求映射所匹配的请求必须不能携带header请求头信息 “header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value “header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value 若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到 7、SpringMVC支持ant风格的路径？：表示任意的单个字符 *：表示任意的0个或多个字符 **：表示任意的一层或多层目录 注意：在使用**时，只能使用/**/xxx的方式 8、SpringMVC支持路径中的占位符（重点）原始方式：/deleteUser?id=1 rest方式：/deleteUser/1 SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参 1&lt;a th:href=&quot;@&#123;/testRest/1/admin&#125;&quot;&gt;测试路径中的占位符--&gt;/testRest&lt;/a&gt;&lt;br&gt; 123456@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)public String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) String username)&#123; System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username); return &quot;success&quot;;&#125;//最终输出的内容为--&gt;id:1,username:admin 四、SpringMVC获取请求参数1、通过ServletAPI获取将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象 1234567@RequestMapping(&quot;/testParam&quot;)public String testParam(HttpServletRequest request)&#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 2、通过控制器方法的形参获取请求参数在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参 1&lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt; 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果 3、@RequestParam@RequestParam是将请求参数和控制器方法的形参创建映射关系 @RequestParam注解一共有三个属性： value：指定为形参赋值的请求参数的参数名 required：设置是否必须传输此请求参数，默认值为true 若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值 4、@RequestHeader@RequestHeader是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 5、@CookieValue@CookieValue是将cookie数据和控制器方法的形参创建映射关系 @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 6、通过POJO获取请求参数可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值 12345678&lt;form th:action=&quot;@&#123;/testpojo&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 123456@RequestMapping(&quot;/testpojo&quot;)public String testPOJO(User user)&#123; System.out.println(user); return &quot;success&quot;;&#125;//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125; 7、解决获取请求参数的乱码问题解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册 1234567891011121314151617&lt;!--配置springMVC的编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效 五、域对象共享数据1、使用ServletAPI向request域对象共享数据12345@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(HttpServletRequest request)&#123; request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;;&#125; 2、使用ModelAndView向request域对象共享数据1234567891011121314@RequestMapping(&quot;/testModelAndView&quot;)public ModelAndView testModelAndView()&#123; /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据 mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;); //设置视图，实现页面跳转 mav.setViewName(&quot;success&quot;); return mav;&#125; 3、使用Model向request域对象共享数据12345@RequestMapping(&quot;/testModel&quot;)public String testModel(Model model)&#123; model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;;&#125; 4、使用map向request域对象共享数据12345@RequestMapping(&quot;/testMap&quot;)public String testMap(Map&lt;String, Object&gt; map)&#123; map.put(&quot;testScope&quot;, &quot;hello,Map&quot;); return &quot;success&quot;;&#125; 5、使用ModelMap向request域对象共享数据12345@RequestMapping(&quot;/testModelMap&quot;)public String testModelMap(ModelMap modelMap)&#123; modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;); return &quot;success&quot;;&#125; 6、Model、ModelMap、Map的关系Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的 1234public interface Model&#123;&#125;public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125; 7、向session域共享数据12345@RequestMapping(&quot;/testSession&quot;)public String testSession(HttpSession session)&#123; session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;;&#125; 8、向application域共享数据123456@RequestMapping(&quot;/testApplication&quot;)public String testApplication(HttpSession session)&#123; ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;); return &quot;success&quot;;&#125; 六、SpringMVC的视图SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为JstlView 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView 1、ThymeleafView当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转 1234@RequestMapping(&quot;/testHello&quot;)public String testHello()&#123; return &quot;hello&quot;;&#125; 2、转发视图SpringMVC中默认的转发视图是InternalResourceView SpringMVC中创建转发视图的情况： 当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转 例如”forward:/“，”forward:/employee” 1234@RequestMapping(&quot;/testForward&quot;)public String testForward()&#123; return &quot;forward:/testHello&quot;;&#125; 3、重定向视图SpringMVC中默认的重定向视图是RedirectView 当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转 例如”redirect:/“，”redirect:/employee” 1234@RequestMapping(&quot;/testRedirect&quot;)public String testRedirect()&#123; return &quot;redirect:/testHello&quot;;&#125; 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径 4、视图控制器view-controller当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示 12345&lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称--&gt;&lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt; 注： 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签： &lt;mvc:annotation-driven /&gt; 七、RESTful1、RESTful简介REST：Representational State Transfer，表现层资源状态转移。 a&gt;资源资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 b&gt;资源的表述资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 c&gt;状态转移状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 2、RESTful的实现具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。 操作 传统方式 REST风格 查询操作 getUserById?id=1 user/1–&gt;get请求方式 保存操作 saveUser user–&gt;post请求方式 删除操作 deleteUser?id=1 user/1–&gt;delete请求方式 更新操作 updateUser user–&gt;put请求方式 3、HiddenHttpMethodFilter由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？ SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求 HiddenHttpMethodFilter 处理put和delete请求的条件： a&gt;当前请求的请求方式必须为post b&gt;当前请求必须传输请求参数_method 满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式 在web.xml中注册HiddenHttpMethodFilter 12345678&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter 原因： 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的 request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作： ```String paramValue = request.getParameter(this.methodParam); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 八、RESTful案例### 1、准备工作和传统 CRUD 一样，实现对员工信息的增删改查。- 搭建环境- 准备实体类 ```java package com.atguigu.mvc.bean; public class Employee &#123; private Integer id; private String lastName; private String email; //1 male, 0 female private Integer gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Employee(Integer id, String lastName, String email, Integer gender) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Employee() &#123; &#125; &#125; 准备dao模拟数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.mvc.dao;import java.util.Collection;import java.util.HashMap;import java.util.Map;import com.atguigu.mvc.bean.Employee;import org.springframework.stereotype.Repository;@Repositorypublic class EmployeeDao &#123; private static Map&lt;Integer, Employee&gt; employees = null; static&#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1)); employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1)); employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0)); employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0)); employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1)); &#125; private static Integer initId = 1006; public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(initId++); &#125; employees.put(employee.getId(), employee); &#125; public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; public Employee get(Integer id)&#123; return employees.get(id); &#125; public void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 2、功能清单 功能 URL 地址 请求方式 访问首页√ / GET 查询全部数据√ /employee GET 删除√ /employee/2 DELETE 跳转到添加数据页面√ /toAdd GET 执行保存√ /employee POST 跳转到更新数据页面√ /employee/2 GET 执行更新√ /employee PUT 3、具体功能：访问首页a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt; b&gt;创建页面1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; &gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/employee&#125;&quot;&gt;访问员工信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4、具体功能：查询所有员工数据a&gt;控制器方法123456@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)public String getEmployeeList(Model model)&#123; Collection&lt;Employee&gt; employeeList = employeeDao.getAll(); model.addAttribute(&quot;employeeList&quot;, employeeList); return &quot;employee_list&quot;;&#125; b&gt;创建employee_list.html123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Employee Info&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;text-align: center;&quot; id=&quot;dataTable&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/toAdd&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 5、具体功能：删除a&gt;创建处理delete请求方式的表单12345&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;&lt;form id=&quot;delete_form&quot; method=&quot;post&quot;&gt; &lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&gt;&lt;/form&gt; b&gt;删除超链接绑定点击事件引入vue.js 1&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; 删除超链接 1&lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; 通过vue处理点击事件 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#dataTable&quot;, methods:&#123; //event表示当前事件 deleteEmployee:function (event) &#123; //通过id获取表单标签 var delete_form = document.getElementById(&quot;delete_form&quot;); //将触发事件的超链接的href属性为表单的action属性赋值 delete_form.action = event.target.href; //提交表单 delete_form.submit(); //阻止超链接的默认跳转行为 event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法12345@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); return &quot;redirect:/employee&quot;;&#125; 6、具体功能：跳转到添加数据页面a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;employee_add&quot;&gt;&lt;/mvc:view-controller&gt; b&gt;创建employee_add.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Add Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 7、具体功能：执行保存a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)public String addEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 8、具体功能：跳转到更新数据页面a&gt;修改超链接1&lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; b&gt;控制器方法123456@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)public String getEmployeeById(@PathVariable(&quot;id&quot;) Integer id, Model model)&#123; Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;, employee); return &quot;employee_update&quot;;&#125; c&gt;创建employee_update.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Update Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;br&gt; &lt;!-- th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显 若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性 --&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;update&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 9、具体功能：执行更新a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)public String updateEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 八、HttpMessageConverterHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文 HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity， ResponseEntity 1、@RequestBody@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值 12345&lt;form th:action=&quot;@&#123;/testRequestBody&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/testRequestBody&quot;)public String testRequestBody(@RequestBody String requestBody)&#123; System.out.println(&quot;requestBody:&quot;+requestBody); return &quot;success&quot;;&#125; 输出结果： requestBody:username=admin&amp;password=123456 2、RequestEntityRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息 123456@RequestMapping(&quot;/testRequestEntity&quot;)public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123; System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders()); System.out.println(&quot;requestBody:&quot;+requestEntity.getBody()); return &quot;success&quot;;&#125; 输出结果：requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”http://localhost:8080&quot;, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]requestBody:username=admin&amp;password=123 3、@ResponseBody@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器 12345@RequestMapping(&quot;/testResponseBody&quot;)@ResponseBodypublic String testResponseBody()&#123; return &quot;success&quot;;&#125; 结果：浏览器页面显示success 4、SpringMVC处理json@ResponseBody处理json的步骤： a&gt;导入jackson的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串 1&lt;mvc:annotation-driven /&gt; c&gt;在处理器方法上使用@ResponseBody注解进行标识 d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串 12345@RequestMapping(&quot;/testResponseUser&quot;)@ResponseBodypublic User testResponseUser()&#123; return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);&#125; 浏览器的页面中展示的结果： {“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”} 5、SpringMVC处理ajaxa&gt;请求超链接： 123&lt;div id=&quot;app&quot;&gt; &lt;a th:href=&quot;@&#123;/testAjax&#125;&quot; @click=&quot;testAjax&quot;&gt;testAjax&lt;/a&gt;&lt;br&gt;&lt;/div&gt; b&gt;通过vue和axios处理点击事件： 12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#app&quot;, methods:&#123; testAjax:function (event) &#123; axios(&#123; method:&quot;post&quot;, url:event.target.href, params:&#123; username:&quot;admin&quot;, password:&quot;123456&quot; &#125; &#125;).then(function (response) &#123; alert(response.data); &#125;); event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法： 123456@RequestMapping(&quot;/testAjax&quot;)@ResponseBodypublic String testAjax(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;hello,ajax&quot;;&#125; 6、@RestController注解@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解 7、ResponseEntityResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文 九、文件上传和下载1、文件下载使用ResponseEntity实现下载文件的功能 123456789101112131415161718192021222324@RequestMapping(&quot;/testDown&quot;)public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123; //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()]; //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;); //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity;&#125; 2、文件上传文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data” SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息 上传步骤： a&gt;添加依赖： 123456&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的配置文件中添加配置： 12&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; c&gt;控制器方法： 12345678910111213141516171819@RequestMapping(&quot;/testUp&quot;)public String testUp(MultipartFile photo, HttpSession session) throws IOException &#123; //获取上传的文件的文件名 String fileName = photo.getOriginalFilename(); //处理文件重名问题 String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); fileName = UUID.randomUUID().toString() + hzName; //获取服务器中photo目录的路径 ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(&quot;photo&quot;); File file = new File(photoPath); if(!file.exists())&#123; file.mkdir(); &#125; String finalPath = photoPath + File.separator + fileName; //实现上传功能 photo.transferTo(new File(finalPath)); return &quot;success&quot;;&#125; 十、拦截器1、拦截器的配置SpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandlerInterceptor SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置： 1234567891011&lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;&lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;&lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/testRequestEntity&quot;/&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;/mvc:interceptor&gt;&lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求--&gt; 2、拦截器的三个抽象方法SpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 postHandle：控制器方法执行之后执行postHandle() afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation() 3、多个拦截器的执行顺序a&gt;若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行 b&gt;若某个拦截器的preHandle()返回了false preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行 十一、异常处理器1、基于配置的异常处理SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式： 123456789101112131415&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、基于注解的异常处理12345678910111213//@ControllerAdvice将当前类标识为异常处理的组件@ControllerAdvicepublic class ExceptionController &#123; //@ExceptionHandler用于设置所标识方法处理的异常 @ExceptionHandler(ArithmeticException.class) //ex表示当前请求处理中出现的异常对象 public String handleArithmeticException(Exception ex, Model model)&#123; model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; &#125;&#125; 十二、注解配置SpringMVC使用配置类和注解代替web.xml和SpringMVC配置文件的功能 1、创建初始化类，代替web.xml在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。 123456789101112131415161718192021222324252627282930313233343536373839404142public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定spring的配置类 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; /** * 指定SpringMVC的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() &#123; CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(&quot;UTF-8&quot;); encodingFilter.setForceRequestEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;; &#125;&#125; 2、创建SpringConfig配置类，代替spring的配置文件1234@Configurationpublic class SpringConfig &#123; //ssm整合之后，spring的配置信息写在此类中&#125; 3、创建WebConfig配置类，代替SpringMVC的配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Configuration//扫描组件@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)//开启MVC注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; //使用默认的servlet处理静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //配置文件上传解析器 @Bean public CommonsMultipartResolver multipartResolver()&#123; return new CommonsMultipartResolver(); &#125; //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; FirstInterceptor firstInterceptor = new FirstInterceptor(); registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;); &#125; //配置视图控制 /*@Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); &#125;*/ //配置异常映射 /*@Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(&quot;ex&quot;); resolvers.add(exceptionResolver); &#125;*/ //配置生成模板解析器 @Bean public ITemplateResolver templateResolver() &#123; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; &#125; //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; &#125; //生成视图解析器并未解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; &#125;&#125; 4、测试功能1234@RequestMapping(&quot;/&quot;)public String index()&#123; return &quot;index&quot;;&#125; 十三、SpringMVC执行流程1、SpringMVC常用组件 DispatcherServlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找Handler，即控制器方法 Handler：处理器，需要工程师开发 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过HandlerAdapter对处理器（控制器方法）进行执行 ViewResolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView View：视图 作用：将模型数据通过页面展示给用户 2、DispatcherServlet初始化过程DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。 a&gt;初始化WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected WebApplicationContext initWebApplicationContext() &#123; WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // No context instance is defined for this servlet -&gt; create a local one // 创建WebApplicationContext wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) &#123; // 刷新WebApplicationContext onRefresh(wac); &#125; &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. // 将IOC容器在应用域共享 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); &#125; return wac;&#125; b&gt;创建WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 1234567891011121314151617181920212223protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); &#125; // 通过反射创建 IOC 容器对象 ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); // 设置父容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) &#123; wac.setConfigLocation(configLocation); &#125; configureAndRefreshWebApplicationContext(wac); return wac;&#125; c&gt;DispatcherServlet初始化策略FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件 所在类：org.springframework.web.servlet.DispatcherServlet 1234567891011protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);&#125; 3、DispatcherServlet调用组件处理请求a&gt;processRequest()FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response) 所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try &#123; // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写 doService(request, response); &#125; catch (ServletException | IOException ex) &#123; failureCause = ex; throw ex; &#125; catch (Throwable ex) &#123; failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); &#125; finally &#123; resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) &#123; requestAttributes.requestCompleted(); &#125; logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); &#125;&#125; b&gt;doService()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; RequestPath requestPath = null; if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123; requestPath = ServletRequestPathUtils.parseAndCache(request); &#125; try &#123; // 处理请求和响应 doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; if (requestPath != null) &#123; ServletRequestPathUtils.clearParsedRequestPath(request); &#125; &#125;&#125; c&gt;doDispatch()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 调用拦截器的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; // 后续处理：处理模型数据和渲染视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; d&gt;processDispatchResult()12345678910111213141516171819202122232425262728293031323334353637383940414243private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // 处理模型数据和渲染视图 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. // 调用拦截器的afterCompletion() mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; 4、SpringMVC的执行流程 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射： a) 不存在 i. 再判断是否配置了mvc:default-servlet-handler ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误 iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误 b) 存在则执行下面的流程 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。 此时将开始执行拦截器的postHandle(…)方法【逆向】。 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。 将渲染结果返回给客户端。"},{"title":"Spring","path":"2022/03/05/spring/","text":"官方：http://spring.io/ 【优点】： 1、Spring是一个开源免费的框架 , 容器 . 2、Spring是一个轻量级的框架 , 非侵入式的 . 3、控制反转 IoC , 面向切面 Aop 4、对事物的支持 , 对框架的支持 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 1、IOC1.1 IOC实现我们先用我们原来的方式写一段代码 . 1、先写一个UserDao接口 123public interface UserDao &#123; public void getUser();&#125; 2、再去写Dao的实现类 123456public class UserDaoImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;获取用户数据&quot;); &#125;&#125; 3、然后去写UserService的接口 123public interface UserService &#123; public void getUser();&#125; 4、最后写Service的实现类 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 5、测试一下 12345@Testpublic void test()&#123; UserService service = new UserServiceImpl(); service.getUser();&#125; 这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 . 把Userdao的实现类增加一个 . 123456public class UserDaoMySqlImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;MySql获取用户数据&quot;); &#125;&#125; 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 在假设, 我们再增加一个Userdao的实现类 . 123456public class UserDaoOracleImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;Oracle获取用户数据&quot;); &#125;&#125; 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 . 那我们如何去解决呢 ? 我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 . 123456789101112public class UserServiceImpl implements UserService &#123; private UserDao userDao;// 利用set实现 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 现在去我们的测试类里 , 进行测试 ; 123456789@Testpublic void test()&#123; UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser();&#125; 1.2 IOC本质控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 2、第一个Spring程序 导入Jar包 注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 . 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; 编写代码 1、编写一个Hello实体类 1234567891011121314public class Hello &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;Hello,&quot;+ name ); &#125;&#125; 2、编写我们的spring文件 , 这里我们命名为beans.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--bean就是java对象 , 由Spring创建和管理--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、我们可以去进行测试了 . 12345678@Testpublic void test()&#123; //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //getBean : 参数即为spring配置文件中bean的id . Hello hello = (Hello) context.getBean(&quot;hello&quot;); hello.show();&#125; 思考 Hello 对象是谁创建的 ? 【hello 对象是由Spring创建的 Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的. IOC是一种编程思想，由主动的编程变成被动的接收 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . 修改案例一 我们在案例一中， 新增一个Spring配置文件beans.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt; &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt; &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt; &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt; &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试！ 123456@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;); serviceImpl.getUser();&#125; OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! 4、IOC创建对象的方式 通过无参构造方法来创建 1、User.java 1234567891011121314151617public class User &#123; private String name; public User() &#123; System.out.println(&quot;user无参构造方法&quot;); &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name ); &#125;&#125; 2、beans.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、测试类 12345678@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //在执行getBean的时候, user已经创建好了 , 通过无参构造 User user = (User) context.getBean(&quot;user&quot;); //调用对象的方法 . user.show();&#125; 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！ 通过有参构造方法来创建 1、UserT . java 1234567891011121314151617public class UserT &#123; private String name; public UserT(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name ); &#125;&#125; 2、beans.xml 有三种方式编写 1234567891011121314&lt;!-- 第一种根据index参数下标设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- index指构造方法 , 下标从0开始 --&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt;&lt;!-- 第二种根据参数名字设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt;&lt;!-- 第三种根据参数类型设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt; 3、测试 123456@Testpublic void testT()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserT user = (UserT) context.getBean(&quot;userT&quot;); user.show();&#125; 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！ 5、Spring配置 别名 alias 设置别名 , 为bean设置别名 , 可以设置多个别名 12&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt; Bean的配置 12345678910111213&lt;!--bean就是java对象,由Spring创建和管理--&gt;&lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;class是bean的全限定名=包名+类名--&gt;&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;&lt;/bean&gt; import 团队的合作通过import来实现 . 1&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt; 6、依赖注入(DI) 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 . 6.1、构造器注入6.2、set注入要求被注入的属性，必须有set方法，set方法的方法名由set+属性首字母大写，如果属性是Boolean类型，没有set方法，是 is 方法 1、常量注入 123&lt;bean id=&quot;student&quot; class=&quot;com.aimer.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; 2、Bean注入 注意：这里的值是一个引用，ref 12345678&lt;bean id=&quot;addr&quot; class=&quot;com.aimer.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.aimer.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt; &lt;/bean&gt; 3、数组注入 12345678910&lt;bean id=&quot;student&quot; class=&quot;com.aimer.pojo.Student&quot;&gt; &lt;property name=&quot;books&quot; &gt; &lt;array&gt; &lt;value&gt;insii-李&lt;/value&gt; &lt;value&gt;wins&lt;/value&gt; &lt;value&gt;aimer-李&lt;/value&gt; &lt;value&gt;period-李&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 4、list注入 1234567&lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听音乐&lt;/value&gt; &lt;value&gt;写字&lt;/value&gt; &lt;value&gt;拍照&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 5、map注入 12345678&lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;安南&quot;/&gt; &lt;entry key=&quot;2&quot; value=&quot;李安安&quot;/&gt; &lt;entry key=&quot;3&quot; value=&quot;姜芃&quot;/&gt; &lt;entry key=&quot;4&quot; value=&quot;aimer&quot;/&gt; &lt;/map&gt; &lt;/property&gt; 6、set注入 1234567&lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 7、Null注入 1&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt; 8、Properties注入 1234567&lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 6.3、p命名和c命名User.java ：【注意：这里没有有参构造器！】 1234567891011121314151617181920public class User &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 1、P命名空间注入：需要在头文件中加入约束条件 123导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.aimer.pojo.User&quot; p:name=&quot;李安安&quot; p:age=&quot;18&quot;/&gt; 2、c 命名空间注入 : 需要在头文件中加入约束文件 123导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.aimer.pojo.User&quot; c:name=&quot;sin&quot; c:age=&quot;18&quot;/&gt; 发现问题：爆红了，刚才我们没有写有参构造！ 解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！ 6.4、bean的作用域在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。 1、单例模式Singleton（Spring默认机制）当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置： 1&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt; 测试： 1234567@Testpublic void test03()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); User user2 = (User) context.getBean(&quot;user&quot;); System.out.println(user==user2);&#125; 2、Prototype当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置： 123&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt; 或者&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt; 3、Request当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。 4、Session当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。 7、Bean的自动装配 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 这里我们主要讲第三种：自动化的装配bean。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。 推荐不使用自动装配xml配置 , 而使用注解 . 1、byNameautowire byName (按名称自动装配) 由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。 采用自动装配将避免这些错误，并且使配置简单化。 测试： 1、修改bean配置，增加一个属性 autowire=”byName” 123&lt;bean id=&quot;people&quot; class=&quot;com.aimer.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;安安&quot;/&gt; &lt;/bean&gt; 2、再次测试，结果依旧成功输出！ 3、我们将 cat 的bean id修改为 catXXX 4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。 小结： 当一个bean节点带有 autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 2、byTypeautowire byType (按类型自动装配) 使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。 1NoUniqueBeanDefinitionException 测试： 1、将user的bean配置修改一下 ： autowire=”byType” 2、测试，正常输出 3、在注册一个cat 的bean对象！ 1234567&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;&lt;/bean&gt; 4、测试，报错：NoUniqueBeanDefinitionException 5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。 这就是按照类型自动装配！ 使用注解自动装配JDK1.5开始支持注解，spring2.5开始全面支持注解 准备工作：利用注解的方式注入属性 1、在spring配置文件中引用context头文件 1234xmlns:context=&quot;http://www.springframework.org/schema/context&quot;http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd 2、开启属性注解支持 1&lt;context:annotation-config/&gt; @Autowired @Autowired是按类型自动转配的，不支持ID匹配 需要导入spring-aop包 测试： 1、将User类中的set方法去掉，使用@Autowired注解 1234567891011121314151617public class User &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() &#123; return cat; &#125; public Dog getDog() &#123; return dog; &#125; public String getStr() &#123; return str; &#125;&#125; 2、此时配置文件内容 12345&lt;context:annotation-config/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 3、测试，成功输出结果！ 【注意】@Autowired(required=false) 说明：false，对象可以为null；true，对象必须存对象，不能为null。 123//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Cat cat; @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。 测试实验步骤： 1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ 1234&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 2、没有加Qualifier测试，直接报错 3、在属性上添加Qualifier注解 123456@Autowired@Qualifier(value = &quot;cat2&quot;)private Cat cat;@Autowired@Qualifier(value = &quot;dog2&quot;)private Dog dog; 测试，成功输出！ @Resource 在JDK11移除了javax.annotation包，所以会报错，导入个javax.annotation即可 @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： 12345678public class User &#123; //如果允许对象为null，设置required = false,默认为true @Resource(name = &quot;cat2&quot;) private Cat cat; @Resource private Dog dog; private String str;&#125; beans.xml 12345&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 测试：结果OK 配置文件2：beans.xml ， 删掉cat2 12&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 实体类上只保留注解 1234@Resourceprivate Cat cat;@Resourceprivate Dog dog; 结果：OK 结论：先进行byName查找，失败；再进行byType查找，成功。 小结@Autowired与@Resource异同： 1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用 3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。 8、注解开发在spring4之后，想要使用注解形式，必须得要引入aop的包 在配置文件当中，还得要引入一个context约束 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 1、Bean的实现我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！ 1、配置扫描哪些包下的注解 12&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.aimer.pojo&quot;/&gt; 2、在指定包下编写类，增加注解 12345@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123; public String name = &quot;秦疆&quot;;&#125; 3、测试 1234567@Testpublic void test()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = (User) applicationContext.getBean(&quot;user&quot;); System.out.println(user.name);&#125; 2、属性注入使用注解注入属性 1、可以不用提供set方法，直接在直接名上添加@value(“值”) 1234567@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123; @Value(&quot;秦疆&quot;) // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt; public String name;&#125; 2、如果提供了set方法，在set方法上添加@value(“值”); 12345678910@Component(&quot;user&quot;)public class User &#123; public String name; @Value(&quot;秦疆&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 3、衍生注解我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ @Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 写上这些注解，就相当于将这个类交给Spring管理装配了！ 自动装配注解 在Bean的自动装配已经讲过了，可以回顾！ 4、作用域@scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 123456@Controller(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User &#123; @Value(&quot;秦疆&quot;) public String name;&#125; 5、小结XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 1&lt;context:annotation-config/&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ 9、基于Java类进行配置JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 测试： 1、编写一个实体类，Dog 1234@Component //将这个类标注为Spring的一个组件，放到容器中！public class Dog &#123; public String name = &quot;dog&quot;;&#125; 2、新建一个config配置包，编写一个MyConfig配置类 12345678910@Configuration //代表这是一个配置类public class MyConfig &#123; @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ //如果想自定义bean的名字在后面通过name设置，还可以设置自动配置方式 public Dog dog()&#123; return new Dog(); &#125;&#125; 3、测试 1234567@Testpublic void test2()&#123;c //ApplicationContext context =new AnnotationConfigApplicationContext(MyConfig.class); ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;); System.out.println(dog.name);&#125; 4、成功输出结果！ 导入其他配置如何做呢？ 1、我们再编写一个配置类！ 123@Configuration //代表这是一个配置类public class MyConfig2 &#123;&#125; 2、在之前的配置类中我们来选择导入这个配置类 12345678910@Configuration@Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签public class MyConfig &#123; @Bean public Dog dog()&#123; return new Dog(); &#125;&#125; 10、代理模式 AOP的底层机制就是动态代理！ 1、静态代理 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 代码实现： 1234//抽象角色：租房public interface Rent &#123; public void rent();&#125; Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;房屋出租&quot;); &#125;&#125; Proxy . java 即代理角色 123456789101112131415161718192021222324//代理角色：中介public class Proxy implements Rent &#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; //租房 public void rent()&#123; seeHouse(); host.rent(); fare(); &#125; //看房 public void seeHouse()&#123; System.out.println(&quot;带房客看房&quot;); &#125; //收中介费 public void fare()&#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; Client . java 即客户 123456789101112//客户类，一般客户都会去找代理！public class Client &#123; public static void main(String[] args) &#123; //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); &#125;&#125; 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式 静态代理的好处: 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 缺点 : 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 . 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! 静态代理再理解 同学们练习完毕后，我们再来举一个例子，巩固大家的学习！ 练习步骤： 1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！ 1234567//抽象角色：增删改查业务public interface UserService &#123; void add(); void delete(); void update(); void query();&#125; 2、我们需要一个真实对象来完成这些增删改查操作 12345678910111213141516171819//真实对象，完成增删改查操作的人public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 3、需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！ 4、设置一个代理类来处理日志！代理角色 123456789101112131415161718192021222324252627282930313233//代理角色，在这里面增加日志的实现public class UserServiceProxy implements UserService &#123; private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) &#123; this.userService = userService; &#125; public void add() &#123; log(&quot;add&quot;); userService.add(); &#125; public void delete() &#123; log(&quot;delete&quot;); userService.delete(); &#125; public void update() &#123; log(&quot;update&quot;); userService.update(); &#125; public void query() &#123; log(&quot;query&quot;); userService.query(); &#125; public void log(String msg)&#123; System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;); &#125;&#125; 5、测试访问类： 123456789101112public class Client &#123; public static void main(String[] args) &#123; //真实业务 UserServiceImpl userService = new UserServiceImpl(); //代理类 UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！ proxy.setUserService(userService); proxy.add(); &#125;&#125; OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想； 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想 2、动态代理 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理—-JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、 JDK的动态代理需要了解两个类 核心 : InvocationHandler 和 Proxy ， 打开JDK帮助文档看看 【InvocationHandler：调用处理程序】 ```public interface InvocationHandler1234567891011 `InvocationHandler`是由代理实例的*调用处理程序*实现的*接口* 。 每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的`invoke`方法。```javaObject invoke(Object proxy, 方法 method, Object[] args)；//参数//proxy - 调用该方法的代理实例//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 【代理proxy】 ```public class Proxyextends Objectimplements Serializable 1234567891011 `Proxy`提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。- 每个代理实例都有一个关联的*调用处理程序*对象，它实现了接口`InvocationHandler返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。- - ```java public static Object newProxyInstance(ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException //返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。 Proxy.newProxyInstance因为与IllegalArgumentException相同的原因而Proxy.getProxyClass 。 参数 loader - 类加载器来定义代理类 interfaces - 代理类实现的接口列表 h - 调度方法调用的调用处理函数 12345//生成代理类public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this);&#125; 代码实现 抽象角色和真实角色和之前的一样！ Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent &#123; public void rent();&#125; Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;房屋出租&quot;); &#125;&#125; ProxyInvocationHandler. java 即代理角色 12345678910111213141516171819202122232425262728293031323334public class ProxyInvocationHandler implements InvocationHandler &#123; private Rent rent; public void setRent(Rent rent) &#123; this.rent = rent; &#125; //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); &#125; // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; &#125; //看房 public void seeHouse()&#123; System.out.println(&quot;带房客看房&quot;); &#125; //收中介费 public void fare()&#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; Client . java 1234567891011121314//租客public class Client &#123; public static void main(String[] args) &#123; //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); &#125;&#125; 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、 深化理解我们来使用动态代理实现代理我们后面写的UserService！ 我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！ 1234567891011121314151617181920212223242526public class ProxyInvocationHandler implements InvocationHandler &#123; private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; //生成代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); Object result = method.invoke(target, args); return result; &#125; public void log(String methodName)&#123; System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;); &#125;&#125; 测试！ 1234567891011public class Test &#123; public static void main(String[] args) &#123; //真实对象 UserServiceImpl userService = new UserServiceImpl(); //代理对象的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); //设置要代理的对象 UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！ proxy.delete(); &#125;&#125; 测试，增删改查，查看结果！ 动态代理的好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ 11、AOP 什么是AOP？ AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 Aop在Spring中的作用 提供声明式事务；允许用户自定义切面 以下名词需要了解下： 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 使用Spring实现Aop【重点】使用AOP织入，需要导入一个依赖包！ 123456&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 第一种方式通过 Spring API 实现 首先编写我们的业务接口和实现类 123456789101112131415161718192021222324252627282930313233public interface UserService &#123; public void add(); public void delete(); public void update(); public void search();&#125;public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;增加用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;更新用户&quot;); &#125; @Override public void search() &#123; System.out.println(&quot;查询用户&quot;); &#125;&#125; 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 12345678910111213141516171819202122public class Log implements MethodBeforeAdvice &#123; //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;); &#125;&#125;public class AfterLog implements AfterReturningAdvice &#123; //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot; + target.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法,&quot; +&quot;返回值：&quot;+returnValue); &#125;&#125; 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试 12345678public class MyTest &#123; @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.search(); &#125;&#125; Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . 第二种方式自定义类来实现Aop 目标业务类不变依旧是userServiceImpl 第一步 : 写我们自己的一个切入类 12345678910public class DiyPointcut &#123; public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125; public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125; &#125; 去spring中配置 12345678910111213&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt; &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试： 12345678public class MyTest &#123; @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.add(); &#125;&#125; 第三种方式使用注解实现 第一步：编写一个注解实现的增强类 123456789101112131415161718192021222324252627282930package com.kuang.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut &#123; @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125; @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125; @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); System.out.println(&quot;签名:&quot;+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); System.out.println(proceed); &#125;&#125; 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置 123&lt;!--第三种方式:注解实现--&gt;&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt; aop:aspectj-autoproxy：说明 123通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 【注意】如果使用Java类配置开发的话，在config配置类加上@EnableAspectJAutoProxy注释 Spring Aop的执行顺序 @Before：前置通知：目标方法之前执行 @After：后置通知：目标方法之后执行 @AfterReturning：返回后通知：执行方法结束前执行 @AfterThrowing：异常通知：出现异常时执行 @Around：环绕通知：环绕目标方法执行 12、整合MyBatis先导入jar包 mybatis: 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; mysql-connector-java: 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; Spring相关： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; aspectJ AOP 织入器: 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; mybatis-spring整合包 【重点】 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; 配置Maven静态资源过滤问题！ 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 设置JDK版本 123456789101112&lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;14&lt;/source&gt; &lt;target&gt;14&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; 1 .整合实现一1、引入Spring配置文件beans.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 2、配置数据源替换mybaits的数据源 1234567&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 3、配置SqlSessionFactory，关联MyBatis 12345678&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuang/dao/*.xml&quot;/&gt; &lt;!-- mybatis和spring只需要一个扫描xml文件即可，两个都注册mapper就会报错--&gt;&lt;/bean&gt; 4、注册sqlSessionTemplate，关联sqlSessionFactory； 12345&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--利用构造器注入--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 5、增加Dao接口的实现类；私有化sqlSessionTemplate 123456789101112131415public class UserDaoImpl implements UserMapper &#123; //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125; &#125; 6、注册bean实现 123&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; 7、测试 1234567 @Test public void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！ 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 2.整合实现二mybatis-spring1.2.3版以上的才有这个 . 官方文档截图 : dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看 1、将我们上面写的UserDaoImpl修改一下 123456public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 2、修改bean的配置 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;//DaoSupport帮我们内置了生成sqlSessionTemplate,所以我们只需要将sqlSessionFactory传过去即可 3、测试 1234567@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 13、事务1.声明式事务 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。 事务四个属性ACID 原子性（atomicity） 事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency） 一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation） 可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability） 事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！ 2.Spring中的事务管理Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 编程式事务管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 声明式事务管理 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。 使用Spring管理事务，注意头文件的约束导入 : tx 1234xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;http://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 事务管理器 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 JDBC事务 123&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 配置好事务管理器后我们需要去配置事务的通知 123456789101112&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; spring事务传播特性： 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为： propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ 配置AOP 导入aop的头文件！ 12345&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.kuang.dao.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt; 进行测试 删掉刚才插入的数据，再次测试！ 1234567@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 思考问题？ 为什么需要配置事务？ 如果不配置，就需要我们手动提交控制事务； 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 14、各种异常BeanDefinitionParsingException："},{"title":"将GitHub的分支作为hexo源文件的仓库","path":"2022/01/12/jiang-github-de-fen-zhi-zuo-wei-hexo-yuan-wen-jian-de-cang-ku/","text":"1、建立仓库关联12cd bloggit remote #查询链接的仓库 我已经做好了仓库的关联，如果没有的话先在本地文件夹初始化，然后链接仓库 12345git initgit remote add origin https://github.com/aimer-period/aimer-period.github.io.gitgit remote 2、提交文件1234git addgit commit -m &quot;源文件&quot;git push -u origin HEAD:分支名#分支名改为你想建立的分支 ​ 我们提交之后仓库就会多出来一个分支，我们把他设为默认，以后就不用特地写分支了 之后修改就像正常的提交一样 ​ 至于这里为什么不先在 Github 上面手动建立分支，然后再在本地建立关联，是因为如果是远程手动建立分支会自动以 master 分支为模板建立一份一模一样的文件，而我们仓库里面 master 分支存的都是经过 hexo 编译的文件，跟源文件完全不一样，新建这样一个分支之后还要手动把里面的文件删掉，另一个原因是如果在远程手动建分支，你在本地还得手动用 git fetch origin 拉取远程分支的更新，然后再手动建立与分支的关联，比较麻烦 3、恢复重装电脑后，或者在其它电脑上想修改博客： 安装git； 安装Nodejs和npm； 使用git clone https://github.com/aimer-period/aimer-period.github.io.git将仓库拷贝至本地； 在文件夹内执行以下命令npm install hexo-cli -g、npm install、npm install hexo-deployer-git。 4、hexo的源文件这里说一下步骤4为什么只需要拷贝6个，而不需要全部： _config.yml站点的配置文件，需要拷贝； themes/主题文件夹，需要拷贝； source博客文章的.md文件，需要拷贝； scaffolds/文章的模板，需要拷贝； package.json安装包的名称，需要拷贝； .gitignore限定在push时哪些文件可以忽略，需要拷贝； .git/主题和站点都有，标志这是一个git项目，不需要拷贝； node_modules/是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝； public是hexo g生成的静态网页，不需要拷贝； .deploy_git同上，hexo g也会生成，不需要拷贝； db.json文件，不需要拷贝。 其实不需要拷贝的文件正是.gitignore中所忽略的。"},{"title":"Hexo搭建博客","path":"2022/01/12/hexo-da-jian-bo-ke/","text":"1、安装node.js直接官网下载安装即可 https://nodejs.org/zh-cn/Node.js 安装后 12node --vnpm --v 查看是否安装成功 安装hexo找一个位置存放文件，我放的是E:\\Study\\program\\blog 在该目录下右击，打开Git Bash Here 输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。 安装完后输入hexo -v验证是否安装成功。 然后就要初始化我们的网站，输入hexo init初始化文件夹，接着输入npm install安装必备的组件。 这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到我们的博客啦，效果如下： 链接GitHub打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 修改最后一行的配置： 1234deploy: type: git repository: https://github.com/aimer-period/aimer-period.github.io branch: main repository修改为你自己的github项目地址。 写文章首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。 然后输入hexo new post &quot;article title&quot;，新建一篇文章。 然后打开E:\\study\\program\\blog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。"}]